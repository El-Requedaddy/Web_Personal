---
title: Roguelike Chibi
link: roguelike-chibi
catalog: true
date: 2026-02-24 00:00:00
description: Context Steering AI、手続き型ダンジョン生成、オブジェクトプールシステム、およびChibiキャラクターデザインを特徴とするUnity製ローグライクゲーム。
cover: /img/cover/1.webp
tags:
  - Unity
  - C#
  - Game Development
  - Artificial Intelligence
  - Roguelike
  - Scriptable Objects
categories:
  - プロジェクト
sticky: false
---

Roguelike Chibiは、Unityで開発されたローグライクビデオゲームです。Context Steeringに基づいたAIシステム、キャラクターと敵のChibi（ちびキャラ）デザイン、オブジェクトの再利用と責任の分離に焦点を当てたモジュラーアーキテクチャを特徴としています。

## 🚀 主な機能

- **Context Steering AI**: 重みベクトルと危険/関心マップに基づく敵の人工知能
- **2種類の敵**: プレイヤーを直接追跡する「Minion」と、距離を保ちながら側面攻撃を行う「Warrior」
- **手続き型生成**: 選択されたキャラクターと難易度に基づいて生成されるダンジョン
- **オブジェクトプール**: メモリ使用量を最適化するための武器インスタンス再利用システム
- **アニメーションシステム**: 移動、攻撃、アイテム使用のアニメーションを管理する `IAnimatorUsaObjeto` インターフェース
- **キャラクターと難易度の選択**: ゲーム開始前にメインメニューから選択可能
- **コントローラーサポート**: キーリマッピングとコントローラー対応を含むオプションメニュー

## 🛠️ 技術スタック

- **エンジン**: Unity
- **言語**: C#
- **パターン**: シングルトン、オブジェクトプール、オブザーバー（静的イベント）、ステートマシン（状態列挙型）
- **データ設計**: ポーションバフやアイテム設定のためのScriptable Objects
- **AI**: Context Steering（ゲームAIの専門文献に基づく）

## 🤖 人工知能 — Context Steering

このAIシステムはプロジェクトの核心技術です。各敵は可能な方向の配列を評価し、候補方向と目標方向（通常はプレイヤー方向）との**内積**を使用して重みを割り当てます。

重みは以下に基づいて調整されます：
- **プレイヤーまでの距離**: 近いほど重みが高くなります
- **安全距離**: Warriorはプレイヤーに近づきすぎる方向にペナルティを与えます
- **危険・関心マップ**: 衝突を回避し、環境に適応するために基本重みをマスクします

### 敵の種類

| タイプ | 動作 |
|---|---|
| **Minion** | 高度なContext Steeringを使用せず、プレイヤーを直接追いかけます |
| **Warrior** | 完全な重みベクトルを使用して距離を保ち、プレイヤーを包囲します |

両タイプとも範囲内に入ると攻撃し、攻撃間のクールダウン時間を守ります。敵の武器は**オブジェクトプール**からランダムに割り当てられます。

## 📦 オブジェクトプール

オブジェクトプールは、事前に作成されたインスタンスを管理するシステムです。ゲーム開始時に、プレハブセットから約20個の武器がインスタンス化されます。敵や宝箱が武器を必要とするとき、実行時に新しいインスタンスを作成するのではなく、プールから取得します。敵が死ぬと、武器は再利用のためにプールに戻されます。

このパターンはガベージコレクタの影響を減らし、ゲームプレイ中のパフォーマンスを安定させます。

## 🏺 インタラクタブル要素

インタラクタブル要素は、インターフェースと継承に基づいた階層に従います：

```
IInteractableElement
├── Item
│   ├── Weapon        ← 衝突オブジェクトベクトル、自己ダメージロジック
│   └── Potion        ← Scriptable Objectとしてのバフ
├── Door              ← 通常のドア / 出口のドア
├── Key               ← ドアを開ける、プレイヤーのリストに保存
└── Container         ← アニメーション付きの宝箱
```

**武器**は独自の衝突ロジックを自律的に管理します：`IDamagable`を実装する`Hitbox`を検索してダメージを適用し、1回の攻撃アニメーションで同じターゲットに2回適用されないようにします。

プレイヤーがアイテムに照準を合わせると**金色の輝き**を放ち、即座に視覚的なフィードバックを提供します。

## 🎨 ユーザーインターフェース (UI)

### プレイヤーの体力
**5つの赤いハート**で表され、各ハートは全体力の20%に相当します。体力を失うと、ハートは比例して黒くなります。

### ポーズメニュー
ゲームプレイ中はいつでもアクセスでき、以下の3つのオプションがあります：
- ゲーム再開
- オプション（ボリューム + キーボード/コントローラーのキー割り当て）
- メインメニューに戻る

### メインメニュー
**キャラクター選択**への直接アクセスを持つスタート画面で、開始前にキャラクター間のナビゲーションや難易度の選択が可能です。

## ⚙️ Unityアーキテクチャ

プロジェクトは3つの主要シーンで構成されています：

1. **メインメニュー**: アニメーション付きキャラクター、UI管理、音楽、シーン間の静的イベントのクリア
2. **ロード画面**: 新しいシーンを表示する前にロード完了を保証するコールバック
3. **ゲームシーン**: すべてのゲームマネージャーを含みます

### 主なマネージャー

| マネージャー | 責任 |
|---|---|
| **GameInput** | 入力をキャプチャし、イベントを通じて移動、攻撃、対話を通知します |
| **GameManager** | ゲーム状態（プレイ中/一時停止/勝利/ゲームオーバー）とスコアを制御するシングルトン |
| **SoundManager** | 他のクラスからのイベントを購読し、一元化されたサウンドエフェクトを再生します |
| **MusicManager** | バックグラウンドミュージックを再生し、音量制御を提供します |
| **DungeonCreator** | 選択されたキャラクターと難易度に基づいてダンジョンプリセットを選択します |
| **DamageFeedbackManager** | ダメージを受けた際にプレイヤーと敵のマテリアルを変更し、視覚的なフィードバックを与えます |

### 状態管理

ゲームの状態は `Playing`、`Paused`、`Victory`、`GameOver` の値を持つ**列挙型（ENUM）**として管理されます。`GameManager`のシングルトンパターンのおかげで、任意のゲームオブジェクトから現在の状態を簡単に照会したり反応したりできます。

## 📝 コードスニペットのハイライト

```csharp
// Context Steering による方向選択
float bestWeight = float.MinValue;
Vector2 bestDirection = Vector2.zero;

for (int i = 0; i < directions.Length; i++)
{
    // 候補方向とプレイヤー方向の内積
    float weight = Vector2.Dot(directions[i], toPlayer.normalized);

    // 危険マップによる調整
    weight -= dangerMap[i];

    // 関心マップによる調整
    weight += interestMap[i];

    if (weight > bestWeight)
    {
        bestWeight = weight;
        bestDirection = directions[i];
    }
}
```

## 🎓 主な学び

このプロジェクトを通じて以下のことを学びました：
- ゲーム開発の専門文献に基づいたAI技術である**Context Steering**の実装
- リアルタイムメモリ管理を最適化するための**オブジェクトプール**パターンの適用
- C#での**インターフェース**と**継承**を使用したクリーンなクラス階層の設計
- **シングルトン**とステートマシンを使用したグローバルゲーム状態の管理
- 独立したマネージャーへの横断的ロジック（サウンド、フィードバック、スコアリング）の集約
- 再利用可能なアイテムデータのためのUnity **Scriptable Objects**の使用
